// Tetris in Vaporlang
// 2017 Will Smith (minkcv)

var previousGPUState;
var GPUState;
var spriteIndex;
var spriteSegment;
var buttons;
var prevButtons;

// General purpose iterators and temporary variables
var i;
var i2;
var x;
var y;
var x2;
var y2;

var renderTileX;
var renderTileY;
var renderSegment;
var renderAddress;

const pieceSegment 79;

// Constants for piece type
const pieceL 0;
const pieceReverseL 1;
const pieceS 2;
const pieceReverseS 3;
const pieceLine 4;
const pieceSquare 5;
var nextPieceType;

var currentPieceType;

var currentRotation;

const tileWidth 8;
const tileHeight 8;

// Current piece tiles
var tile1X;
var tile1Y;
var tile2X;
var tile2Y;
var tile3X;
var tile3Y;
var tile4X;
var tile4Y;

// True (1) when a piece hits an existing tile
var hitBelow;
// True when the current piece can move right
var canMoveRight;
// True when the current piece can move left
var canMoveLeft;
// True when the current piece can rotate
var canRotate;

// Arguments and return values for getTileXY and getXYFromTile
var getX;
var getY;
var getXY;

// Arguments to setTileXY
var setX;
var setY;
var setXY; // True or false value of tile

const nCols 8;
const nRows 16;

// Number of tiles at [ 0 , 0 ] through [ 0 , 255 ]
// Stored in xy pairs
var nTiles;

var tileIndex;
var tileIndex2;
var rowIndex;
var colIndex;

var waitCounter;

call initSprites;
call reset;
[ 127 , 17 ] = 1; // Enable GPU

call newPiece;

// Main loop
while 1 {
    buttons = [ 127 , 0 ];
    if buttons & 4 == 4 { // Left
        if prevButtons & 4 == 0 {
            call checkMoveLeft;
            if canMoveLeft {
                call movePieceLeft;
            }
        }
    }
    if buttons & 8 == 8 { // Right
        if prevButtons & 8 == 0 {
            call checkMoveRight;
            if canMoveRight {
                call movePieceRight;
            }
        }
    }
    if buttons & 2 == 2 {
        // Drop piece
        waitCounter = 0;
    }
    prevButtons = buttons;
    if waitCounter == 0 {
        call checkHitBelow;
        if hitBelow {
            call addPieceToTiles;
            call newPiece;
        }
        if hitBelow == 0 {
            call movePieceDown;
        }

        if buttons & 1 == 1 {
            // TODO: rotations
        }

        // Slow things down the fewer tiles we have
        // because having more of them will also slow things down.
        waitCounter = 40;
        if nTiles > 30 {
            waitCounter = 30;
            if nTiles > 50 {
                waitCounter = 20;
                if nTiles > 70 {
                    waitCounter = 10;
                }
            }
        }
    }
    waitCounter = waitCounter - 1;

    call render;
    call waitScreen;
}

func addPieceToTiles {
    [ 0 , nTiles ] = tile1X;
    [ 0 , nTiles + 1 ] = tile1Y;
    nTiles = nTiles + 2;
    [ 0 , nTiles ] = tile2X;
    [ 0 , nTiles + 1 ] = tile2Y;
    nTiles = nTiles + 2;
    [ 0 , nTiles ] = tile3X;
    [ 0 , nTiles + 1 ] = tile3Y;
    nTiles = nTiles + 2;
    [ 0 , nTiles ] = tile4X;
    [ 0 , nTiles + 1 ] = tile4Y;
    nTiles = nTiles + 2;
}

func movePieceDown {
    tile1Y = tile1Y + 1;
    tile2Y = tile2Y + 1;
    tile3Y = tile3Y + 1;
    tile4Y = tile4Y + 1;
}

func movePieceRight {
    tile1X = tile1X + 1;
    tile2X = tile2X + 1;
    tile3X = tile3X + 1;
    tile4X = tile4X + 1;
}

func movePieceLeft {
    tile1X = tile1X - 1;
    tile2X = tile2X - 1;
    tile3X = tile3X - 1;
    tile4X = tile4X - 1;
}

func checkHitBelow {
    hitBelow = 0;
    // Check if a tile is at the bottom
    if tile1Y == nRows - 1{
        hitBelow = 1;
        return;
    }
    if tile2Y == nRows - 1{
        hitBelow = 1;
        return;
    }
    if tile3Y == nRows - 1{
        hitBelow = 1;
        return;
    }
    if tile4Y == nRows - 1{
        hitBelow = 1;
        return;
    }
    // Check if a tile hits a tile below
    i = 0;
    while i < nTiles {
        x = [ 0 , i ];
        y = [ 0 , i + 1 ];
        if tile1X == x {
            if tile1Y + 1 == y {
                hitBelow = 1;
                return;
            }
        }
        if tile2X == x {
            if tile2Y + 1 == y {
                hitBelow = 1;
                return;
            }
        }
        if tile3X == x {
            if tile3Y + 1 == y {
                hitBelow = 1;
                return;
            }
        }
        if tile4X == x {
            if tile4Y + 1 == y {
                hitBelow = 1;
                return;
            }
        }

        i = i + 2;
    }
}

func checkMoveRight {
    canMoveRight = 1;
    // Check the right boundary
    if tile1X == nCols - 1 {
        canMoveRight = 0;
        return;
    }
    if tile2X == nCols - 1 {
        canMoveRight = 0;
        return;
    }
    if tile3X == nCols - 1 {
        canMoveRight = 0;
        return;
    }
    if tile4X == nCols - 1 {
        canMoveRight = 0;
        return;
    }
    // Check if a tile hits a tile to the right
    i = 0;
    while i < nTiles {
        // Optimization note, instead of adding 1 to each tilex,
        // just subtract one from current tile x
        x = [ 0 , i ];
        x = x - 1;
        y = [ 0 , i + 1 ];
        if tile1Y == y {
            if tile1X == x {
                canMoveRight = 0;
                return;
            }
        }
        if tile2Y == y {
            if tile2X == x {
                canMoveRight = 0;
                return;
            }
        }
        if tile3Y == y {
            if tile3X == x {
                canMoveRight = 0;
                return;
            }
        }
        if tile4Y == y {
            if tile4X == x {
                canMoveRight = 0;
                return;
            }
        }
        i = i + 1;
    }
}

func checkMoveLeft {
    canMoveLeft = 1;
    // Check the left boundary
    if tile1X == 0 {
        canMoveLeft = 0;
        return;
    }
    if tile2X == 0 {
        canMoveLeft = 0;
        return;
    }
    if tile3X == 0 {
        canMoveLeft = 0;
        return;
    }
    if tile4X == 0 {
        canMoveLeft = 0;
        return;
    }
    // Check if a tile hits a tile to the left
    i = 0;
    while i < nTiles {
        // Optimization note, instead of subtracting 1 from each tilex,
        // just add one to current tile x
        x = 1 + [ 0 , i ];
        y = [ 0 , i + 1 ];
        if tile1Y == y {
            if tile1X == x {
                canMoveLeft = 0;
                return;
            }
        }
        if tile2Y == y {
            if tile2X == x {
                canMoveLeft = 0;
                return;
            }
        }
        if tile3Y == y {
            if tile3X == x {
                canMoveLeft = 0;
                return;
            }
        }
        if tile4Y == y {
            if tile4X == x {
                canMoveLeft = 0;
                return;
            }
        }
        i = i + 1;
    }
}

func newPiece {
    if nextPieceType == pieceL {
        tile1X = 3;
        tile1Y = 0;
        tile2X = 4;
        tile2Y = 0;
        tile3X = 5;
        tile3Y = 0;
        tile4X = 5;
        tile4Y = 1;
        nextPieceType = pieceS;
        return;
    }
    if nextPieceType == pieceReverseL {
        tile1X = 3;
        tile1Y = 0;
        tile2X = 4;
        tile2Y = 0;
        tile3X = 5;
        tile3Y = 0;
        tile4X = 3;
        tile4Y = 1;
        nextPieceType = pieceL;
        return;
    }
    if nextPieceType == pieceS {
        tile1X = 5;
        tile1Y = 0;
        tile2X = 4;
        tile2Y = 0;
        tile3X = 4;
        tile3Y = 1;
        tile4X = 3;
        tile4Y = 1;
        nextPieceType = pieceLine;
        return;
    }
    if nextPieceType == pieceReverseS {
        tile1X = 4;
        tile1Y = 0;
        tile2X = 3;
        tile2Y = 0;
        tile3X = 4;
        tile3Y = 1;
        tile4X = 5;
        tile4Y = 1;
        nextPieceType = pieceSquare;
        return;
    }
    if nextPieceType == pieceLine {
        tile1X = 3;
        tile1Y = 0;
        tile2X = 4;
        tile2Y = 0;
        tile3X = 5;
        tile3Y = 0;
        tile4X = 6;
        tile4Y = 0;
        nextPieceType = pieceReverseS;
        return;
    }
    if nextPieceType == pieceSquare {
        tile1X = 3;
        tile1Y = 0;
        tile2X = 3;
        tile2Y = 1;
        tile3X = 4;
        tile3Y = 0;
        tile4X = 4;
        tile4Y = 1;
        nextPieceType = pieceReverseL;
        return;
    }
}

func render {
    renderAddress = 0;
    renderSegment = 64;
    i = 0;
    while i < nTiles {
        renderTileX = [ 0 , i ];
        renderTileY = [ 0 , i + 1 ];
        call renderTile;
        
        if renderAddress == 240 {
            renderSegment = renderSegment + 1;
        }
        renderAddress = renderAddress + 16;
        i = i + 2;
    }
    renderSegment = pieceSegment;
    renderAddress = 0;
    renderTileX = tile1X;
    renderTileY = tile1Y;
    call renderTile;
    renderAddress = renderAddress + 16;
    renderTileX = tile2X;
    renderTileY = tile2Y;
    call renderTile;
    renderAddress = renderAddress + 16;
    renderTileX = tile3X;
    renderTileY = tile3Y;
    call renderTile;
    renderAddress = renderAddress + 16;
    renderTileX = tile4X;
    renderTileY = tile4Y;
    call renderTile;
}

// IN: renderTileX renderTileY renderSegment renderAddress
func renderTile {
    [ renderSegment , renderAddress ] = 128; // Enable
    x2 = 0;
    i2 = 0;
    while i2 < tileWidth {
        x2 = x2 + renderTileX;
        i2 = i2 + 1;
    }
    y2 = 0;
    i2 = 0;
    while i2 < tileHeight {
        y2 = y2 + renderTileY;
        i2 = i2 + 1;
    }
    [ renderSegment , renderAddress + 1 ] = x2;
    [ renderSegment , renderAddress + 2 ] = y2;
}

func reset {
}

func initSprites {
    spriteIndex = 0;
    spriteSegment = 64;
    i = 0;
    while i < 128 {
        [ spriteSegment , spriteIndex ] = 0; // Disable
        [ spriteSegment , spriteIndex + 3 ] = tileWidth;
        [ spriteSegment , spriteIndex + 4 ] = tileHeight;
        [ spriteSegment , spriteIndex + 5 ] = 128; // Sprite data segment
        [ spriteSegment , spriteIndex + 7 ] = 255; // White
        if spriteIndex == 240 {
            spriteSegment = spriteSegment + 1;
        }
        spriteIndex = spriteIndex + 16;
        i = i + 1;
    }
    spriteIndex = 0;
    while spriteIndex < 64 {
        [ pieceSegment , spriteIndex ] = 0; // Disable
        [ pieceSegment , spriteIndex + 3 ] = tileWidth;
        [ pieceSegment , spriteIndex + 4 ] = tileHeight;
        [ pieceSegment , spriteIndex + 5 ] = 128; // Sprite data segment
        [ pieceSegment , spriteIndex + 7 ] = 255; // White
        spriteIndex = spriteIndex + 16;
    }
}

func waitScreen {
    while  GPUState == previousGPUState {
        GPUState = [ 127 , 17 ];
        GPUState = GPUState & 2;
    }
    previousGPUState = GPUState;
}

